diff --git a/README.md b/README.md
index afad2b1..ff3e652 100644
--- a/README.md
+++ b/README.md
@@ -13,7 +13,7 @@ These are the main applications nitro is designed for:
 - As unprivileged supervision daemon on generic POSIX systems
 
 nitro is configured by a directory of scripts, defaulting to
-`/etc/nitro` (or the first command line argument).
+`/etc/nitro/services (or the first command line argument).
 
 ## Requirements
 
@@ -39,7 +39,7 @@ nitro is configured by a directory of scripts, defaulting to
 
 ## Services
 
-Every directory inside `/etc/nitro` (or your custom service directory)
+Every directory inside `/etc/nitro/services` (or your custom service directory)
 can contain several files:
 
 - `setup`, an optional executable file that is run before the service starts.
@@ -195,7 +195,7 @@ Where COMMAND is one of:
 - t: send signal SIGTERM to SERVICE
 - k: send signal SIGKILL to SERVICE
 - pidof: print the PID of the SERVICE, or return 1 if it's not up
-- rescan: re-read `/etc/nitro`, start added daemons, stop removed daemons
+- rescan: re-read `/etc/nitro/services`, start added daemons, stop removed daemons
 - Shutdown: shutdown (poweroff) the system
 - Reboot: reboot the system
 
@@ -236,7 +236,7 @@ the appropriate target.
 You can add this line to `/etc/ttys` to run `nitro` supervised by
 FreeBSD `init`:
 
-	/etc/nitro "/usr/local/sbin/nitro" "" on
+	/etc/nitro/services "/usr/local/sbin/nitro" "" on
 
 ## Periodic jobs
 
diff --git a/nitro.8 b/nitro.8
index f484baa..391d0b1 100644
--- a/nitro.8
+++ b/nitro.8
@@ -13,7 +13,7 @@ is a service supervisor that can be used as a Unix init system.
 .Pp
 Every directory inside
 .Ar dir
-.Pq by default: Pa /etc/nitro
+.Pq by default: Pa /etc/nitro/services
 defines a service.
 .Pp
 When used as init, and the argument
diff --git a/nitro.c b/nitro.c
index 66974d9..738a246 100644
--- a/nitro.c
+++ b/nitro.c
@@ -139,11 +139,12 @@ int controlsock;
 int nullfd;
 int selfpipe[2];
 int globallog[2];
+const char *ndir;		/*the base directory eg /etc/nitro*/
+char sdir[PATH_MAX];	/*the services directory eg realpath(/etc/nitro/services)*/
 DIR *cwd;
 DIR *notifydir;
 char notifypath[256];
 const char *control_socket_path;
-const char *servicedir = "/etc/nitro";
 
 long total_reaps;
 long total_sv_reaps;
@@ -302,6 +303,13 @@ panic()
 #define dprn(...) {}
 #endif
 
+int
+services_realpath(char *tsdir){
+	char buf[PATH_MAX];
+	sprn(buf, buf + sizeof buf, "%s/services", ndir);
+	return realpath(buf,tsdir)!=NULL;
+}
+
 int
 stat_slash(const char *dir, const char *name, struct stat *st)
 {
@@ -1135,36 +1143,42 @@ refresh_log:
 	return i;
 }
 
-static void
-reopendir(DIR **d)
-{
-#ifdef REOPEN_USE_CLOSEDIR
-	DIR *newd = opendir(servicedir);
-	if (!newd)
-		return;
-	closedir(*d);
-	*d = newd;
-	(void)!fchdir(dirfd(newd));
-#else
-
-	// avoid OpenBSD bug: ensure we hit end, so rewinddir forces re-read.
-	while (readdir(*d))
-		;
-
-#ifdef REOPEN_USE_DUP_HACK
-	// this fiddles in the internals of DIR, use only if you vetted
-	// your libc to tolerate this!
-	int fd = open(servicedir, O_RDONLY | O_DIRECTORY | O_CLOEXEC);
-	if (fd >= 0) {
-		if (dup3(fd, dirfd(*d), O_CLOEXEC) < 0)
-			close(fd);
-		else
-			(void)!fchdir(dirfd(*d));
+int
+check_sdir(){
+	/*
+	 * check to see if the realpath of ndir has changed
+	 * and if yes fix up sdir and cwd
+	 * */
+	char tsdir[PATH_MAX];
+	int rval = 0;
+	/*check to see if the real path changed*/
+	if (!services_realpath(tsdir)){
+		dprn("check_services: '%s/services' is invalid\n", ndir);
+		rval = 1;
+	} else if(strcmp(sdir,tsdir)){
+		DIR	*tcwd=NULL;
+		dprn("services: '%s' --> '%s'\n", sdir, tsdir);
+		/*new services*/
+		if (chdir(tsdir) < 0){
+			dprn("chdir to '%s': errno=%d\n", sdir, errno);
+			rval = 2;
+		} else {
+			tcwd = opendir(".");
+			if (!tcwd){
+				dprn("opendir '%s': errno=%d\n", sdir, errno);
+				rval = 3;
+			} else {
+				closedir(cwd);	/*close current*/
+				cwd = tcwd;		/*set the globals*/
+				strncpy(sdir,tsdir,PATH_MAX);
+			}
+		}
+	} else {
+		// avoid OpenBSD bug: ensure we hit end, so rewinddir forces re-read.
+		while (readdir(cwd))
+			;
 	}
-#endif
-
-	rewinddir(*d);
-#endif
+	return rval;
 }
 
 void
@@ -1175,8 +1189,8 @@ rescan()
 	for (i = 0; i < max_service; i++)
 		services[i].seen = 0;
 
-	reopendir(&cwd);
-
+	check_sdir();
+	rewinddir(cwd);
 	struct dirent *ent;
 	while ((ent = readdir(cwd))) {
 		char *name = ent->d_name;
@@ -1518,16 +1532,9 @@ handle_control_sock()
 	case 'd':
 	case 'r':
 	{
-		struct stat st;
-
 		if (!buf[1])
 			goto fail;
 		int i = find_service(buf + 1);
-		if (i < 0 &&
-		    buf[0] != 'd' &&
-		    valid_service_name(buf + 1) &&
-		    stat_slash_to_at(buf + 1, ".", &st) == 0)
-			i = add_service(buf + 1);
 		if (i < 0)
 			goto fail;
 		services[i].seen = 1;
@@ -1833,17 +1840,21 @@ main(int argc, char *argv[])
 			close(voidfd);
 	}
 
+	ndir = "/etc/nitro";
 	if (argc == 2)
-		servicedir = argv[1];
-	if (real_pid1 && (strcmp(servicedir, "S") == 0 || strcmp(servicedir, "single") == 0))
-		servicedir = "/etc/nitro.single";
+		ndir = argv[1];
+	if (real_pid1 && (strcmp(ndir, "S") == 0 || strcmp(ndir, "single") == 0))
+		ndir = "/etc/nitro.single";
 
-	cwd = opendir(servicedir);
-	if (!cwd)
-		fatal("opendir '%s': errno=%d\n", servicedir, errno);
+	if(!services_realpath(sdir)){
+		fatal("bad realpath for %s/services: errno=%d\n", ndir, errno);
+		}
+	if (chdir(sdir) < 0)
+		fatal("chdir to '%s': errno=%d\n", sdir, errno);
 
-	if (fchdir(dirfd(cwd)) < 0)
-		fatal("fchdir to '%s': errno=%d\n", servicedir, errno);
+	cwd = opendir(".");
+	if (!cwd)
+		fatal("opendir '%s': errno=%d\n", sdir, errno);
 
 	if (pipe2(selfpipe, O_NONBLOCK | O_CLOEXEC) < 0)
 		fatal("selfpipe pipe: errno=%d\n", errno);
diff --git a/nitroctl.c b/nitroctl.c
index 2a90b50..5ff7c25 100644
--- a/nitroctl.c
+++ b/nitroctl.c
@@ -324,7 +324,7 @@ main(int argc, char *argv[])
 			execvp("nitro", argv);
 			dprintf(2, "nitroctl: exec init failed: %s\n", strerror(errno));
 
-			if (chdir(argc == 2 ? argv[1] : "/etc/nitro") < 0)
+			if (chdir(argc == 2 ? argv[1] : "/etc/nitro/services") < 0)
 				dprintf(2, "nitroctl: chdir failed: %s\n", strerror(errno));
 			execl("SYS/fatal", "SYS/fatal", (char *)0);
 			dprintf(2, "nitroctl: exec SYS/fatal failed: %s\n", strerror(errno));

diff --git a/README.md b/README.md
index 3922a80..a09e0d9 100644
--- a/README.md
+++ b/README.md
@@ -13,7 +13,7 @@ These are the main applications nitro is designed for:
 - As unprivileged supervision daemon on generic POSIX systems
 
 nitro is configured by a directory of scripts, defaulting to
-`/etc/nitro` (or the first command line argument).
+`/etc/nitro/services` (or the first command line argument).
 
 ## Requirements
 
@@ -39,7 +39,7 @@ nitro is configured by a directory of scripts, defaulting to
 
 ## Services
 
-Every directory inside `/etc/nitro` (or your custom service directory)
+Every directory inside `/etc/nitro/services` (or your custom service directory)
 can contain several files:
 
 - `setup`, an optional executable file that is run before the service starts.
@@ -211,7 +211,7 @@ Where COMMAND is one of:
 - t: send signal SIGTERM to SERVICE
 - k: send signal SIGKILL to SERVICE
 - pidof: print the PID of the SERVICE, or return 1 if it's not up
-- rescan: re-read `/etc/nitro`, start added daemons, stop removed daemons
+- rescan: re-read `/etc/nitro/services`, start added daemons, stop removed daemons
 - Shutdown: shutdown (poweroff) the system
 - Reboot: reboot the system
 
@@ -276,7 +276,7 @@ the appropriate target.
 You can add this line to `/etc/ttys` to run `nitro` supervised by
 FreeBSD `init`:
 
-	/etc/nitro "/usr/local/sbin/nitro" "" on
+	/etc/nitro/services "/usr/local/sbin/nitro" "" on
 
 ## Periodic jobs
 
diff --git a/nitro.8 b/nitro.8
index f484baa..391d0b1 100644
--- a/nitro.8
+++ b/nitro.8
@@ -13,7 +13,7 @@ is a service supervisor that can be used as a Unix init system.
 .Pp
 Every directory inside
 .Ar dir
-.Pq by default: Pa /etc/nitro
+.Pq by default: Pa /etc/nitro/services
 defines a service.
 .Pp
 When used as init, and the argument
diff --git a/nitro.c b/nitro.c
index 9b77313..2527aa6 100644
--- a/nitro.c
+++ b/nitro.c
@@ -14,6 +14,7 @@
 #ifdef __linux__
 #include <sys/mount.h>
 #include <sys/reboot.h>
+#include <sys/statvfs.h>
 #endif
 #ifdef __NetBSD__
 #include <sys/mount.h>
@@ -139,7 +140,8 @@ DIR *cwd;
 DIR *notifydir;
 char notifypath[256];
 const char *control_socket_path;
-const char *servicedir = "/etc/nitro";
+char servicedir[PATH_MAX];	/*the services directory eg realpath(/etc/nitro/services)*/
+const char *basedir;			/*the base directory eg /etc/nitro*/
 
 long total_reaps;
 long total_sv_reaps;
@@ -292,6 +294,13 @@ panic()
 #else
 #define dprn(...) {}
 #endif
+ 
+int
+services_realpath(char *tsdir){
+	char buf[PATH_MAX];
+	sprn(buf, buf + sizeof buf, "%s/services", basedir);
+	return realpath(buf,tsdir)!=NULL;
+}
 
 int
 stat_slash(const char *dir, const char *name, struct stat *st)
@@ -1145,36 +1154,40 @@ refresh_log:
 	return i;
 }
 
-static void
-reopendir(DIR **d)
-{
-#ifdef REOPEN_USE_CLOSEDIR
-	DIR *newd = opendir(servicedir);
-	if (!newd)
-		return;
-	closedir(*d);
-	*d = newd;
-	(void)!fchdir(dirfd(newd));
-#else
-
-	// avoid OpenBSD bug: ensure we hit end, so rewinddir forces re-read.
-	while (readdir(*d))
-		;
-
-#ifdef REOPEN_USE_DUP_HACK
-	// this fiddles in the internals of DIR, use only if you vetted
-	// your libc to tolerate this!
-	int fd = open(servicedir, O_RDONLY | O_DIRECTORY | O_CLOEXEC);
-	if (fd >= 0) {
-		if (dup3(fd, dirfd(*d), O_CLOEXEC) < 0)
-			close(fd);
-		else
-			(void)!fchdir(dirfd(*d));
+int
+check_sdir(){
+	/*
+	 * check to see if the realpath of basedir has changed
+	 * and if yes fix up servicedir and cwd
+	 * */
+	char tsdir[PATH_MAX];
+	int rval = 0;
+	/*check to see if the real path changed*/
+	if (!services_realpath(tsdir)){
+		dprn("check_services: '%s/services' is invalid\n", basedir);
+		rval = 1;
+	} else if(strcmp(servicedir,tsdir)){
+		DIR	*tcwd=NULL;
+		dprn("services: '%s' --> '%s'\n", servicedir, tsdir);
+		/*new services*/
+		tcwd = opendir(tsdir);
+		if (!tcwd){
+			dprn("opendir '%s': errno=%d\n", tsdir, errno);
+			rval = 2;
+		} else if (fchdir(dirfd(tcwd)) < 0){
+				dprn("chdir to '%s': errno=%d\n", tsdir, errno);
+				rval = 3;
+		} else {
+			closedir(cwd);	/*close current*/
+			cwd = tcwd;		/*set the globals*/
+			strncpy(servicedir,tsdir,PATH_MAX);
+		}
+	} else {
+		// avoid OpenBSD bug: ensure we hit end, so rewinddir forces re-read.
+		while (readdir(cwd))
+			;
 	}
-#endif
-
-	rewinddir(*d);
-#endif
+	return rval;
 }
 
 void
@@ -1185,8 +1198,8 @@ rescan()
 	for (i = 0; i < max_service; i++)
 		services[i].seen = 0;
 
-	reopendir(&cwd);
-
+	check_sdir();
+	rewinddir(cwd);
 	struct dirent *ent;
 	while ((ent = readdir(cwd))) {
 		char *name = ent->d_name;
@@ -1575,19 +1588,13 @@ handle_control_sock()
 	case T_CMD_RESTART:
 	case T_CMD_READY:
 	{
-		struct stat st;
-
 		if (len == 0)
 			goto fail;
 
-		int i;
-		if ((cmd != T_CMD_DOWN || find_service("SYS") != -1) &&
-		    cmd != T_CMD_READY &&
-		    valid_service_name(sv) &&
-		    stat_slash_to_at(sv, ".", &st) == 0)
-			i = add_service(sv);
-		else
-			i = find_service(sv);
+		int i = find_service(sv);
+		if (i < 0)
+ 			goto fail;
+ 		services[i].seen = 1;
 		if (i < 0)
 			goto fail;
 		services[i].seen = 1;
@@ -1896,10 +1903,13 @@ main(int argc, char *argv[])
 			close(voidfd);
 	}
 
-	if (argc == 2)
-		servicedir = argv[1];
-	if (real_pid1 && (strcmp(servicedir, "S") == 0 || strcmp(servicedir, "single") == 0))
-		servicedir = "/etc/nitro.single";
+	basedir = (argc == 2) ? argv[1] : "/etc/nitro";
+	if (real_pid1 && (strcmp(basedir, "S") == 0 || strcmp(basedir, "single") == 0))
+		basedir = "/etc/nitro.single";
+
+	if(!services_realpath(servicedir)){
+		fatal("bad realpath for %s/services: errno=%d\n", basedir, errno);
+		}
 
 	cwd = opendir(servicedir);
 	if (!cwd)
@@ -2098,10 +2108,25 @@ again:
 		}
 
 #ifdef __linux__
-		if (mount("/", "/", "", MS_REMOUNT | MS_RDONLY, "") < 0)
-			prn(2, "- nitro: could not remount / read-only: errno=%d\n", errno);
+		// Get filesystem stats
+		struct statvfs rootst;
+		int	rootro, r;
+		if ((r=statvfs("/", &rootst)) != 0) {
+			prn(2, "- nitro: could not check / read-only: errno=%d return=%d\n", errno, r);
+			rootro = -1;
+		}
+		else
+			// Check if the filesystem is read-only
+			rootro = (rootst.f_flag & ST_RDONLY) ? 1 : 0;
+
+		if (rootro != 1){
+			if (mount("/", "/", "", MS_REMOUNT | MS_RDONLY, "") < 0)
+				prn(2, "- nitro: could not remount / read-only: errno=%d\n", errno);
+			else
+				prn(2, "- nitro: remounted / read-only\n");
+		}
 		else
-			prn(2, "- nitro: remounted / read-only\n");
+			prn(2, "- nitro: / already read-only\n");
 #endif
 #ifdef __NetBSD__
 		char args[256];
diff --git a/nitroctl.c b/nitroctl.c
index 6d12671..8712057 100644
--- a/nitroctl.c
+++ b/nitroctl.c
@@ -611,7 +611,7 @@ main(int argc, char *argv[])
 			execvp("nitro", argv);
 			dprintf(2, "nitroctl: exec init failed: %s\n", strerror(errno));
 
-			if (chdir(argc == 2 ? argv[1] : "/etc/nitro") < 0)
+			if (chdir(argc == 2 ? argv[1] : "/etc/nitro/services") < 0)
 				dprintf(2, "nitroctl: chdir failed: %s\n", strerror(errno));
 			execl("SYS/fatal", "SYS/fatal", (char *)0);
 			dprintf(2, "nitroctl: exec SYS/fatal failed: %s\n", strerror(errno));
